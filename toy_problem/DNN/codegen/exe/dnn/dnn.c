/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 * File: dnn.c
 *
 * MATLAB Coder version            : 5.2
 * C/C++ source code generated on  : 18-May-2023 18:03:10
 */

/* Include Files */
#include "dnn.h"
#include "rt_nonfinite.h"
#include "rt_nonfinite.h"
#include <math.h>

/* Function Declarations */
static void poslin_apply(const double n[4], double a[4]);

/* Function Definitions */
/*
 * Arguments    : const double n[4]
 *                double a[4]
 * Return Type  : void
 */
static void poslin_apply(const double n[4], double a[4])
{
  int partialTrueCount;
  int trueCount;
  signed char tmp_data[4];
  boolean_T unnamed_idx_0;
  boolean_T unnamed_idx_1;
  boolean_T unnamed_idx_2;
  boolean_T unnamed_idx_3;
  /*  Linear Positive Transfer Function */
  trueCount = 0;
  a[0] = fmax(0.0, n[0]);
  unnamed_idx_3 = rtIsNaN(n[0]);
  unnamed_idx_0 = unnamed_idx_3;
  if (unnamed_idx_3) {
    trueCount = 1;
  }
  a[1] = fmax(0.0, n[1]);
  unnamed_idx_3 = rtIsNaN(n[1]);
  unnamed_idx_1 = unnamed_idx_3;
  if (unnamed_idx_3) {
    trueCount++;
  }
  a[2] = fmax(0.0, n[2]);
  unnamed_idx_3 = rtIsNaN(n[2]);
  unnamed_idx_2 = unnamed_idx_3;
  if (unnamed_idx_3) {
    trueCount++;
  }
  a[3] = fmax(0.0, n[3]);
  unnamed_idx_3 = rtIsNaN(n[3]);
  if (unnamed_idx_3) {
    trueCount++;
  }
  partialTrueCount = 0;
  if (unnamed_idx_0) {
    tmp_data[0] = 1;
    partialTrueCount = 1;
  }
  if (unnamed_idx_1) {
    tmp_data[partialTrueCount] = 2;
    partialTrueCount++;
  }
  if (unnamed_idx_2) {
    tmp_data[partialTrueCount] = 3;
    partialTrueCount++;
  }
  if (unnamed_idx_3) {
    tmp_data[partialTrueCount] = 4;
  }
  for (partialTrueCount = 0; partialTrueCount < trueCount; partialTrueCount++) {
    a[tmp_data[partialTrueCount] - 1] = rtNaN;
  }
}

/*
 * DNN neural network simulation function.
 *
 *  Auto-generated by MATLAB, 17-May-2023 14:17:28.
 *
 *  [y1] = dnn(x1) takes these arguments:
 *    x = 4xQ matrix, input #1
 *  and returns:
 *    y = 1xQ matrix, output #1
 *  where Q is the number of samples.
 *
 * Arguments    : const double x1[4]
 * Return Type  : double
 */
double dnn(const double x1[4])
{
  static const double b_a[16] = {
      0.22885314587390795, 1.2989262737861031,  -1.222833024667348,
      2.4478055793981435,  0.13307400841301062, -1.4543577114449149,
      1.2369151081494527,  -1.1218863602137479, 1.0960579809856668,
      -3.2849789461202263, 0.68382885975223662, -2.4572892702714819,
      -1.3541817671636516, 3.4806381819363348,  -0.68893352191392654,
      3.95712891489493};
  static const double c_a[16] = {
      0.80292187017053951,  0.032089982498598596,  0.51957572016897935,
      0.030953673173799986, -0.4570006502036022,   -0.86258767000016079,
      -1.0751742318177486,  -0.855914448394104,    0.20627558941628615,
      1.1840973661685636,   1.2679462557067245,    1.1775503719415235,
      -0.49877108793855152, 0.0069582055879481054, 0.65362411694193367,
      0.0026517301294963942};
  static const double d_a[16] = {
      0.022620465161685203, -0.010855648521799655, 0.33288292799784769,
      0.55550670107122768,  -1.0675922553691313,   -0.334695014391028,
      -0.67410380617855981, -0.8631534110821304,   0.035496203164151759,
      -0.13793478761423872, -0.48712181771339746,  0.770961537567771,
      1.0043453013958321,   -0.37653528359280708,  0.34640592979839907,
      -0.67803479420555179};
  double a[4];
  double b[4];
  double b_b[4];
  double xp1[4];
  double d;
  double d1;
  double d2;
  double d3;
  int i;
  /*  ===== NEURAL NETWORK CONSTANTS ===== */
  /*  Input 1 */
  /*  Layer 1 */
  /*  Layer 2 */
  /*  Layer 3 */
  /*  Layer 4 */
  /*  Output 1 */
  /*  ===== SIMULATION ======== */
  /*  Dimensions */
  /*  samples */
  /*  Input 1 */
  /*  ===== MODULE FUNCTIONS ======== */
  /*  Map Minimum and Maximum Input Processing Function */
  /*  Layer 1 */
  /*  Layer 2 */
  /*  Layer 3 */
  a[0] = -0.4195364110126843;
  b[0] = 0.31013957257504204;
  b_b[0] = 0.031980965257826753;
  a[1] = 0.7936066670859353;
  b[1] = -0.50030038418383227;
  b_b[1] = -0.13103466750532722;
  a[2] = 0.30553822813434522;
  b[2] = 0.97736428090845862;
  b_b[2] = -0.025661597288851506;
  a[3] = 0.28373882571771364;
  b[3] = 1.3596571404340667;
  b_b[3] = 0.75311544166919453;
  /*  Layer 4 */
  /*  Output 1 */
  /*  Map Minimum and Maximum Output Reverse-Processing Function */
  d = (x1[0] - -3.79770925411727) * 0.271628507479075 + -1.0;
  d1 = (x1[1] - -3.98685739103758) * 0.256256615215467 + -1.0;
  d2 = (x1[2] - -3.60704945724341) * 0.263221989367581 + -1.0;
  d3 = (x1[3] - -3.88268403945963) * 0.251342961695645 + -1.0;
  for (i = 0; i < 4; i++) {
    xp1[i] = a[i] + (((b_a[i] * d + b_a[i + 4] * d1) + b_a[i + 8] * d2) +
                     b_a[i + 12] * d3);
  }
  poslin_apply(xp1, a);
  d = a[0];
  d1 = a[1];
  d2 = a[2];
  d3 = a[3];
  for (i = 0; i < 4; i++) {
    xp1[i] = b[i] + (((c_a[i] * d + c_a[i + 4] * d1) + c_a[i + 8] * d2) +
                     c_a[i + 12] * d3);
  }
  poslin_apply(xp1, a);
  d = a[0];
  d1 = a[1];
  d2 = a[2];
  d3 = a[3];
  for (i = 0; i < 4; i++) {
    b[i] = b_b[i] + (((d_a[i] * d + d_a[i + 4] * d1) + d_a[i + 8] * d2) +
                     d_a[i + 12] * d3);
  }
  poslin_apply(b, a);
  return (((((-1.0405317199860771 * a[0] + 0.30393306780545282 * a[1]) +
             -0.0051844352325778227 * a[2]) +
            0.046773788894185583 * a[3]) +
           0.99813910164962472) -
          -1.0) /
             2.0 +
         -0.5;
}

/*
 * File trailer for dnn.c
 *
 * [EOF]
 */

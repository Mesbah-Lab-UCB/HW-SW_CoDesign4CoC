function [params, obj, obj_true] = approx_msMPC_HIL(params, data_save_file, varargin)
% function to run a closed-loop simulation of the msMPC on hardware. the input
% arguments to this function are considered to be Python types and must be
% converted to the appropriate MATLAB types first.
%
% params - the params argument parameterizes the closed-loop implementation
%       which currently supports the parameters related to the DNN
%       construction (number of nodes H and number of hidden layers L),
%       parameters related to hardware implementation (option to unroll
%       loops and fixed point word length)
% data_save_file - the data_save_file argument denotes the location of the
%       data for training a DNN (generated by either gathering open-loop or
%       closed-loop data of an MPC system)
%
% Name-Value Pair Arguments:
%

% convert required arguments from Python types to MATLAB types
params = struct(params);
data_save_file = char(data_save_file);

%% default optimizable parameters
Nsamp = 1000;
Np = 5;
H = 5;
L = 3;
loopOpt = 'LoopNone';
fxp_word_length = 18;

%% unpack optimizable parameters
fnames = fieldnames(params);
for i = 1:length(fnames)
    switch fnames{i}
        case 'H'
            H = double(params.(fnames{i}))
        case 'L'
            L = double(params.(fnames{i}))
        case 'loopOpt'
            loopOpt = char(params.(fnames{i}))
        case 'fxp_word_length'
            fxp_word_length = double(params.(fnames{i}))
        case 'Np'
            Np = double(params.(fnames{i}))
        case 'Nsamp'
            Nsamp = double(params.(fnames{i}))
        otherwise
            disp('unsupported parameter...')
    end
end
% H = double(params.H);
% L = double(params.L);
% loopOpt = char(params.loopOpt);
% fxp_word_length = double(params.fxp_word_length);

%% default Name-Value pair arguments
casadipath = '~/casadi-linux-matlab-v3.5.5';
skip_mpc_test = false; % test closed-loop MPC simulation
skip_dnn_test = false; % test closed-loop DNN simulation
use_perf_obj = true; % use performance objective
hw_obj = false;  % use memory objective as second objective
save_file = [];  % save filename for closed-loop results
save_prefix = []; % save filename prefix (for customization and automation of experiments)
train_dnn = false; % switch to train DNN
open_loop_data = false; % switch to use open loop or closed loop data generation for DNN
font_size = 15; % font size for plotting (if plotting enabled)
line_width = 3; % line width for plotting (if plotting enabled)
rand_seed2 = 0; % second random seed for simulation (for different noise realizations)
codegen_dir = './hdlcoder_fullDNN'; % codegen project filepath
exp_runs = false; % switch to toggle experimental run configurations

%% parse Name-Value pair arguments
if nargin > 3
    for i = 1:2:length(varargin)
        name = lower(varargin{i});
        value = varargin{i+1};
        switch name
            case 'casadi_path'
                casadipath = value;
            case 'skip_mpc_test'
                skip_mpc_test = value;
            case 'skip_dnn_test'
                skip_dnn_test = value;
            case 'save_file'
                save_file = value;
            case 'save_prefix'
                save_prefix = value;
                save_file = [save_prefix ...
                             '_sim_data_H' num2str(H) ...
                             '_L' num2str(L) ...
                             '_wrdlen' num2str(fxp_word_length) ...
                             '_' loopOpt];
            case 'train_dnn'
                train_dnn = value;
            case 'open_loop_data'
                open_loop_data = value;
            case 'font_size'
                font_size = value;
            case 'line_width'
                line_width = value;
            case 'rand_seed2'
                rand_seed2 = value;
            case 'hw_obj'
                hw_obj = value;
            case 'use_perf_obj'
                use_perf_obj = value;
            case 'codegen_dir'
                codegen_dir = value;
            case 'exp_runs'
                exp_runs = value;
            otherwise
                warning('Name not recognized. Value not assigned.')
        end
    end
end

%% add package paths
addpath(genpath('./config'), genpath('./utils'),genpath('../Model_ID'),genpath('./codegen_helpers'),genpath(codegen_dir))
addpath(casadipath)

%% load problem data
if exp_runs
    prob_info = multistage_load_problem_info_exp(); % use this for generating experimental runs
else
    prob_info = multistage_load_problem_info(); % use this for purely simulation-based runs
end

% prob_info.Np = Np;

%% set up controller
c = MultistageMPC(prob_info);
c = c.get_mpc();

%% initialize simulation
Nsim = 240;
sim = Simulation(Nsim, prob_info);
if ~skip_mpc_test
    % run simulation
    [sim, sim_data] = sim.run_closed_loop(c, [], [], true, true);
    disp('sim_data fields:')
    disp(fieldnames(sim_data))

    sim_ref = sim_data.Yrefsim;
    CEMsim = sim_data.CEMsim(:,1:end-1);
    mask = CEMsim < sim_ref;
    ctime = sim_data.ctime(mask);
    fprintf('Total Runtime: %.4f s\n', sum(ctime))
    fprintf('Average Runtime: %.4f s\n', mean(ctime))
end

%% initialize and train DNN
dnn = DNN();
if train_dnn
    disp('Collecting training data...')
    if open_loop_data
        dnn = dnn.collect_training_data_open_loop(c, Nsamp);
    else
        dnn = dnn.collect_training_data_closed_loop(c, Nsamp, ceil(sum(mask)*1.5));
    end
else
    loaded = load(data_save_file);
    dnn.inputs = loaded.inputs;
    dnn.outputs = loaded.outputs;
    dnn.input_min = loaded.input_min;
    dnn.input_max = loaded.input_max;
    dnn.output_min = loaded.output_min;
    dnn.output_max = loaded.output_max;
end

disp('Building Neural Network...')
dnn = dnn.build_neural_network(H,L,'relu');
disp('Training Neural Network...')
dnn = dnn.train_neural_network();

%% test dnn in closed-loop simulation
if ~skip_dnn_test
    dnn = dnn.create_casadi_function(true);
    [sim, sim_data1] = sim.run_closed_loop(dnn, [], [], true, true);
    disp('sim_data fields:')
    disp(fieldnames(sim_data1))

    sim_ref1 = sim_data1.Yrefsim;
    CEMsim1 = sim_data1.CEMsim(:,1:end-1);
    mask1 = CEMsim1 < sim_ref1;
    ctime1 = sim_data1.ctime(mask1);
    fprintf('Total Runtime: %.4f s\n', sum(ctime1))
    fprintf('Average Runtime: %.4f s\n', mean(ctime1))
end

%% generate MATLAB Function of neural network
% NOTE: remember to scale inputs/outputs when using this function!!
rmpath(casadipath)
genFunction(dnn.net, [codegen_dir '/plasma_nn.m'], 'MatrixOnly', 'yes')
addpath(casadipath)
inputs = dnn.inputs;
outputs = dnn.outputs;
input_min = dnn.input_min;
input_max = dnn.input_max;
output_min = dnn.output_min;
output_max = dnn.output_max;
net = dnn.net;
save(data_save_file, 'casadipath', ...
    'inputs', 'outputs', ...
    'input_min', 'input_max', ...
    'output_min', 'output_max', 'net') % save NN data

%% build hw controller
sf.input_min = input_min;
sf.input_max = input_max;
sf.output_min = output_min;
sf.output_max = output_max;

hw_params.loopOpt = loopOpt;
hw_params.fxp_word_length = fxp_word_length;

hw_ctrl = HWController('plasma_nn_wrapper', 'test_fullDNN', sf);
hw_ctrl = hw_ctrl.setCodegenDir(codegen_dir);
%% closed-loop simulation with hardware-in-the-loop
try
    hw_ctrl = hw_ctrl.buildController(hw_params);

    [sim, sim_data2] = sim.run_closed_loop(hw_ctrl, [], [], true, true, 'rand_seed2', rand_seed2);
    disp('sim_data fields:')
    disp(fieldnames(sim_data2))

    if ~isempty(save_file)
        save(save_file, 'sim_data2', 'params', 'prob_info')
    end

    % compute closed-loop objectives
    k = sim_data2.CEM_stop_time;
    sim_ref2 = sim_data2.Yrefsim(:,1:k);
    CEMsim2 = sim_data2.CEMsim(:,1:k);
    Tsim = sim_data2.Ysim(1,1:k)+prob_info.xssp(1);
    ctime2 = sim_data2.ctime(1:k-1);
    fprintf('Total Runtime: %.4f s\n', sum(ctime2))
    fprintf('Average Runtime: %.4f s\n', mean(ctime2))
    % performance objective is based on closed-loop thermal dose metric
    perf_obj = sum((CEMsim2 - sim_ref2).^2, 'all');
    % constraint objective is based on amount of constraint violation
    Tmax = prob_info.y_max(1)+prob_info.xss(1);
    cons_obj = sum((Tsim(Tsim > Tmax) - Tmax).^2, 'all');
catch e
    % catch errors for automation purposes
    disp('Potential error occurred during HW code generation')
    disp(e)
    perf_obj = 1e3;
    cons_obj = 1e3;
end

if hw_obj
    % hardware objective is based on memory requirements to store DNN
    % weights (determined by network size and numeric representation)
    n_in = size(inputs,1);
    n_out = size(outputs,1);
    resource_obj = fxp_word_length*(n_in*(H+1)+H*(H+1)*L+H*(n_out+1));
    obj_2 = resource_obj;
    obj_2_true = resource_obj;
else
    obj_2 = cons_obj;
    obj_2_true = cons_obj;
end

if use_perf_obj
  obj_1 = perf_obj;
  obj_1_true = perf_obj;
else
  obj_1 = cons_obj;
  obj_1_true = cons_obj;
end

obj = [obj_1; obj_2];
obj_true = [obj_1_true; obj_2_true];

%% remove package paths
rmpath(genpath('./config'), genpath('./utils'),genpath('../Model_ID'))
end
